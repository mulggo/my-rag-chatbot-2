{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 02. Bedrock 클라이언트 구현\n",
    "\n",
    "AWS Bedrock과 Knowledge Base를 활용한 RAG 시스템의 핵심 클라이언트를 구현합니다.\n",
    "\n",
    "## 📋 구현 목표\n",
    "1. Bedrock 클라이언트 초기화\n",
    "2. RetrieveAndGenerate API 호출\n",
    "3. 에러 처리 및 로깅\n",
    "4. 응답 파싱 및 포맷팅"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 1. 환경 설정 및 라이브러리 import"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 15,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "✅ 라이브러리 import 완료\n"
     ]
    }
   ],
   "source": [
    "import boto3\n",
    "import json\n",
    "import os\n",
    "from typing import Dict, List, Optional, Any\n",
    "from botocore.exceptions import ClientError\n",
    "import logging\n",
    "from datetime import datetime\n",
    "from dotenv import load_dotenv\n",
    "\n",
    "# .env 파일 로드\n",
    "load_dotenv()\n",
    "\n",
    "# 로깅 설정\n",
    "logging.basicConfig(level=logging.INFO)\n",
    "logger = logging.getLogger(__name__)\n",
    "\n",
    "print(\"✅ 라이브러리 import 완료\")\n",
    "\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 2. 환경 변수 확인"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "🌍 AWS Region: us-west-2\n",
      "🧠 Knowledge Base ID: CSCXXZALGC\n",
      "🤖 Model ID: anthropic.claude-3-7-sonnet-20250219-v1:0\n",
      "✅ 환경 변수 로드 완료!\n"
     ]
    }
   ],
   "source": [
    "# 환경 변수에서 설정값 가져오기\n",
    "region = os.environ.get('AWS_REGION', 'us-west-2')\n",
    "#kb_id = 'my-rag-kb-da2f0737'\n",
    "kb_id = os.environ.get('BEDROCK_KNOWLEDGE_BASE_ID')\n",
    "model_id = os.environ.get('BEDROCK_MODEL_ID', 'anthropic.claude-3-haiku-20240307-v1:0')\n",
    "\n",
    "print(f\"🌍 AWS Region: {region}\")\n",
    "print(f\"🧠 Knowledge Base ID: {kb_id}\")\n",
    "print(f\"🤖 Model ID: {model_id}\")\n",
    "\n",
    "if not kb_id:\n",
    "    print(\"⚠️ BEDROCK_KNOWLEDGE_BASE_ID가 설정되지 않았습니다.\")\n",
    "    print(\"01_aws_setup.ipynb의 8번 섹션을 실행했는지 확인하세요.\")\n",
    "else:\n",
    "    print(\"✅ 환경 변수 로드 완료!\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 3. Bedrock 클라이언트 클래스 구현"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 17,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "✅ BedrockClient 클래스 정의 완료\n"
     ]
    }
   ],
   "source": [
    "class BedrockClient:\n",
    "    \"\"\"AWS Bedrock을 활용한 RAG 클라이언트\"\"\"\n",
    "    \n",
    "    def __init__(self, region_name: str = 'us-west-2', knowledge_base_id: str = None, model_id: str = None):\n",
    "        \"\"\"\n",
    "        Bedrock 클라이언트 초기화\n",
    "        \n",
    "        Args:\n",
    "            region_name: AWS 리전\n",
    "            knowledge_base_id: Bedrock Knowledge Base ID\n",
    "            model_id: 사용할 Foundation Model ID\n",
    "        \"\"\"\n",
    "        self.region_name = region_name\n",
    "        self.knowledge_base_id = knowledge_base_id\n",
    "        self.model_id = model_id or 'anthropic.claude-3-7-sonnet-20250219-v1:0'\n",
    "        \n",
    "        # Bedrock Agent Runtime 클라이언트 초기화\n",
    "        try:\n",
    "            self.bedrock_agent_runtime = boto3.client(\n",
    "                'bedrock-agent-runtime',\n",
    "                region_name=self.region_name\n",
    "            )\n",
    "            logger.info(f\"✅ Bedrock Agent Runtime 클라이언트 초기화 완료 (Region: {self.region_name})\")\n",
    "        except Exception as e:\n",
    "            logger.error(f\"❌ Bedrock 클라이언트 초기화 실패: {e}\")\n",
    "            raise\n",
    "    \n",
    "    def retrieve_and_generate(self, query: str, session_id: str = None) -> Dict[str, Any]:\n",
    "        \"\"\"\n",
    "        Knowledge Base를 활용한 RAG 검색 및 답변 생성\n",
    "        \n",
    "        Args:\n",
    "            query: 사용자 질문\n",
    "            session_id: 대화 세션 ID (선택사항)\n",
    "            \n",
    "        Returns:\n",
    "            Dict containing response, sources, and metadata\n",
    "        \"\"\"\n",
    "        if not self.knowledge_base_id:\n",
    "            raise ValueError(\"Knowledge Base ID가 설정되지 않았습니다.\")\n",
    "        \n",
    "        try:\n",
    "            # RetrieveAndGenerate API 호출 파라미터 구성\n",
    "            params = {\n",
    "                'input': {\n",
    "                    'text': query\n",
    "                },\n",
    "                'retrieveAndGenerateConfiguration': {\n",
    "                    'type': 'KNOWLEDGE_BASE',\n",
    "                    'knowledgeBaseConfiguration': {\n",
    "                        'knowledgeBaseId': self.knowledge_base_id,\n",
    "                        'modelArn': f'arn:aws:bedrock:{self.region_name}::foundation-model/{self.model_id}',\n",
    "                        'retrievalConfiguration': {\n",
    "                            'vectorSearchConfiguration': {\n",
    "                                'numberOfResults': 5,\n",
    "                                'overrideSearchType': 'HYBRID'\n",
    "                            }\n",
    "                        }\n",
    "                    }\n",
    "                }\n",
    "            }\n",
    "            \n",
    "            # 세션 ID가 있으면 추가\n",
    "            if session_id:\n",
    "                params['sessionId'] = session_id\n",
    "            \n",
    "            logger.info(f\"🔍 Knowledge Base 검색 시작: {query[:50]}...\")\n",
    "            \n",
    "            # API 호출\n",
    "            response = self.bedrock_agent_runtime.retrieve_and_generate(**params)\n",
    "            \n",
    "            # 응답 파싱\n",
    "            result = self._parse_response(response)\n",
    "            \n",
    "            logger.info(f\"✅ 검색 완료: {len(result.get('sources', []))}개 소스 발견\")\n",
    "            \n",
    "            return result\n",
    "            \n",
    "        except ClientError as e:\n",
    "            error_code = e.response['Error']['Code']\n",
    "            error_message = e.response['Error']['Message']\n",
    "            logger.error(f\"❌ Bedrock API 오류 [{error_code}]: {error_message}\")\n",
    "            \n",
    "            return {\n",
    "                'answer': f\"죄송합니다. 검색 중 오류가 발생했습니다: {error_message}\",\n",
    "                'sources': [],\n",
    "                'session_id': session_id,\n",
    "                'error': True,\n",
    "                'error_code': error_code\n",
    "            }\n",
    "            \n",
    "        except Exception as e:\n",
    "            logger.error(f\"❌ 예상치 못한 오류: {e}\")\n",
    "            \n",
    "            return {\n",
    "                'answer': f\"죄송합니다. 예상치 못한 오류가 발생했습니다: {str(e)}\",\n",
    "                'sources': [],\n",
    "                'session_id': session_id,\n",
    "                'error': True\n",
    "            }\n",
    "    \n",
    "    def _parse_response(self, response: Dict[str, Any]) -> Dict[str, Any]:\n",
    "        \"\"\"\n",
    "        Bedrock 응답을 파싱하여 구조화된 결과 반환\n",
    "        \n",
    "        Args:\n",
    "            response: Bedrock API 원본 응답\n",
    "            \n",
    "        Returns:\n",
    "            파싱된 응답 데이터\n",
    "        \"\"\"\n",
    "        try:\n",
    "            # 기본 응답 추출\n",
    "            output = response.get('output', {})\n",
    "            answer = output.get('text', '답변을 생성할 수 없습니다.')\n",
    "            \n",
    "            # 소스 정보 추출\n",
    "            sources = []\n",
    "            citations = response.get('citations', [])\n",
    "            \n",
    "            for citation in citations:\n",
    "                retrieved_references = citation.get('retrievedReferences', [])\n",
    "                \n",
    "                for ref in retrieved_references:\n",
    "                    source_info = {\n",
    "                        'content': ref.get('content', {}).get('text', ''),\n",
    "                        'location': ref.get('location', {}),\n",
    "                        'metadata': ref.get('metadata', {})\n",
    "                    }\n",
    "                    \n",
    "                    # S3 URI에서 파일명 추출\n",
    "                    s3_uri = source_info['location'].get('s3Location', {}).get('uri', '')\n",
    "                    if s3_uri:\n",
    "                        source_info['filename'] = s3_uri.split('/')[-1]\n",
    "                    \n",
    "                    sources.append(source_info)\n",
    "            \n",
    "            return {\n",
    "                'answer': answer,\n",
    "                'sources': sources,\n",
    "                'session_id': response.get('sessionId'),\n",
    "                'timestamp': datetime.now().isoformat(),\n",
    "                'error': False\n",
    "            }\n",
    "            \n",
    "        except Exception as e:\n",
    "            logger.error(f\"❌ 응답 파싱 오류: {e}\")\n",
    "            return {\n",
    "                'answer': '응답을 처리하는 중 오류가 발생했습니다.',\n",
    "                'sources': [],\n",
    "                'session_id': None,\n",
    "                'error': True\n",
    "            }\n",
    "    \n",
    "    def get_knowledge_base_info(self) -> Dict[str, Any]:\n",
    "        \"\"\"\n",
    "        현재 설정된 Knowledge Base 정보 반환\n",
    "        \n",
    "        Returns:\n",
    "            Knowledge Base 설정 정보\n",
    "        \"\"\"\n",
    "        return {\n",
    "            'knowledge_base_id': self.knowledge_base_id,\n",
    "            'model_id': self.model_id,\n",
    "            'region': self.region_name\n",
    "        }\n",
    "\n",
    "print(\"✅ BedrockClient 클래스 정의 완료\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 4. 클라이언트 인스턴스 생성 및 테스트"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "metadata": {},
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "INFO:__main__:✅ Bedrock Agent Runtime 클라이언트 초기화 완료 (Region: us-west-2)\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "✅ BedrockClient 인스턴스 생성 완료\n",
      "\n",
      "📋 클라이언트 설정 정보:\n",
      "  knowledge_base_id: CSCXXZALGC\n",
      "  model_id: anthropic.claude-3-7-sonnet-20250219-v1:0\n",
      "  region: us-west-2\n"
     ]
    }
   ],
   "source": [
    "# Bedrock 클라이언트 인스턴스 생성\n",
    "try:\n",
    "    bedrock_client = BedrockClient(\n",
    "        region_name=region,\n",
    "        knowledge_base_id=kb_id,\n",
    "        model_id=model_id\n",
    "    )\n",
    "    \n",
    "    print(\"✅ BedrockClient 인스턴스 생성 완료\")\n",
    "    \n",
    "    # 설정 정보 출력\n",
    "    info = bedrock_client.get_knowledge_base_info()\n",
    "    print(\"\\n📋 클라이언트 설정 정보:\")\n",
    "    for key, value in info.items():\n",
    "        print(f\"  {key}: {value}\")\n",
    "        \n",
    "except Exception as e:\n",
    "    print(f\"❌ 클라이언트 생성 실패: {e}\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 5. 테스트 문서 업로드 및 Knowledge Base 동기화"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import time\n",
    "\n",
    "# 테스트 문서 생성 및 업로드\n",
    "def create_and_upload_test_documents():\n",
    "    \"\"\"테스트용 문서들을 생성하고 S3에 업로드\"\"\"\n",
    "    \n",
    "    # 테스트 문서 내용\n",
    "    test_documents = {\n",
    "        'rag_system_guide.txt': '''\n",
    "# RAG (Retrieval-Augmented Generation) 시스템 가이드\n",
    "\n",
    "## RAG란 무엇인가?\n",
    "RAG는 검색 증강 생성(Retrieval-Augmented Generation)의 줄임말로, 외부 지식 베이스에서 관련 정보를 검색한 후 이를 바탕으로 답변을 생성하는 AI 시스템입니다.\n",
    "\n",
    "## RAG의 주요 장점\n",
    "1. **최신 정보 활용**: 실시간으로 업데이트되는 외부 데이터 활용 가능\n",
    "2. **정확성 향상**: 검증된 소스 문서를 기반으로 한 답변 생성\n",
    "3. **투명성**: 답변의 근거가 되는 소스 문서 제공\n",
    "4. **도메인 특화**: 특정 분야의 전문 지식 활용 가능\n",
    "\n",
    "## RAG 시스템 구성 요소\n",
    "- **문서 저장소**: S3, 데이터베이스 등\n",
    "- **벡터 데이터베이스**: OpenSearch, Pinecone 등\n",
    "- **임베딩 모델**: 텍스트를 벡터로 변환\n",
    "- **생성 모델**: Claude, GPT 등 LLM\n",
    "''',\n",
    "        \n",
    "        'aws_bedrock_features.txt': '''\n",
    "# AWS Bedrock 주요 기능\n",
    "\n",
    "## Foundation Models\n",
    "AWS Bedrock은 다양한 Foundation Model을 제공합니다:\n",
    "- **Anthropic Claude**: 대화형 AI, 긴 컨텍스트 처리\n",
    "- **Amazon Titan**: 텍스트 생성 및 임베딩\n",
    "- **Cohere**: 텍스트 생성 및 분류\n",
    "- **Meta Llama**: 오픈소스 기반 모델\n",
    "\n",
    "## Knowledge Base\n",
    "- **자동 문서 처리**: PDF, 텍스트, 이미지 등 다양한 형식 지원\n",
    "- **벡터 검색**: 의미 기반 문서 검색\n",
    "- **멀티모달 지원**: 텍스트와 이미지를 함께 처리\n",
    "\n",
    "## 보안 및 규정 준수\n",
    "- **데이터 프라이버시**: 고객 데이터는 모델 학습에 사용되지 않음\n",
    "- **암호화**: 전송 중 및 저장 시 데이터 암호화\n",
    "- **IAM 통합**: 세밀한 권한 관리\n",
    "''',\n",
    "        \n",
    "        'multimodal_processing.txt': '''\n",
    "# 멀티모달 문서 처리\n",
    "\n",
    "## 지원 파일 형식\n",
    "- **텍스트**: .txt, .md, .csv\n",
    "- **문서**: .pdf, .docx\n",
    "- **이미지**: .jpg, .jpeg, .png\n",
    "\n",
    "## 처리 과정\n",
    "1. **파일 업로드**: S3 버킷에 문서 저장\n",
    "2. **파싱**: Claude 모델을 사용한 멀티모달 파싱\n",
    "3. **청킹**: 계층형 청킹으로 문서 분할\n",
    "4. **임베딩**: Titan 모델로 벡터 변환\n",
    "5. **인덱싱**: OpenSearch에 벡터 저장\n",
    "\n",
    "## 최적화 팁\n",
    "- 이미지는 고해상도보다 텍스트가 명확한 것이 중요\n",
    "- PDF는 텍스트 기반이 OCR보다 정확\n",
    "- 문서 구조를 명확히 하면 청킹 품질 향상\n",
    "'''\n",
    "    }\n",
    "    \n",
    "    print(\"📄 테스트 문서 생성 및 업로드 시작...\")\n",
    "    \n",
    "    uploaded_files = []\n",
    "    \n",
    "    for filename, content in test_documents.items():\n",
    "        try:\n",
    "            # S3에 업로드\n",
    "            s3_client.put_object(\n",
    "                Bucket=s3_bucket_name,\n",
    "                Key=f'documents/{filename}',\n",
    "                Body=content.encode('utf-8'),\n",
    "                ContentType='text/plain'\n",
    "            )\n",
    "            uploaded_files.append(filename)\n",
    "            print(f\"✅ {filename} 업로드 완료\")\n",
    "            \n",
    "        except Exception as e:\n",
    "            print(f\"❌ {filename} 업로드 실패: {e}\")\n",
    "    \n",
    "    print(f\"\\n📊 총 {len(uploaded_files)}개 테스트 문서 업로드 완료\")\n",
    "    return uploaded_files\n",
    "\n",
    "# 테스트 문서 업로드 실행\n",
    "test_files = create_and_upload_test_documents()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Knowledge Base 동기화 (데이터 소스 ingestion)\n",
    "def sync_knowledge_base(kb_id, data_source_id):\n",
    "    \"\"\"Knowledge Base와 S3 데이터 소스 동기화\"\"\"\n",
    "    try:\n",
    "        print(\"🔄 Knowledge Base 동기화 시작...\")\n",
    "        \n",
    "        # Ingestion Job 시작\n",
    "        response = bedrock_agent_client.start_ingestion_job(\n",
    "            knowledgeBaseId=kb_id,\n",
    "            dataSourceId=data_source_id,\n",
    "            description='Test documents ingestion'\n",
    "        )\n",
    "        \n",
    "        job_id = response['ingestionJob']['ingestionJobId']\n",
    "        print(f\"📋 Ingestion Job ID: {job_id}\")\n",
    "        \n",
    "        # Job 상태 모니터링\n",
    "        print(\"⏳ 동기화 진행 상황 모니터링...\")\n",
    "        \n",
    "        while True:\n",
    "            job_status = bedrock_agent_client.get_ingestion_job(\n",
    "                knowledgeBaseId=kb_id,\n",
    "                dataSourceId=data_source_id,\n",
    "                ingestionJobId=job_id\n",
    "            )\n",
    "            \n",
    "            status = job_status['ingestionJob']['status']\n",
    "            print(f\"📊 상태: {status}\")\n",
    "            \n",
    "            if status == 'COMPLETE':\n",
    "                print(\"✅ Knowledge Base 동기화 완료!\")\n",
    "                \n",
    "                # 통계 정보 출력\n",
    "                stats = job_status['ingestionJob'].get('statistics', {})\n",
    "                if stats:\n",
    "                    print(f\"📈 처리된 문서: {stats.get('numberOfDocumentsScanned', 0)}개\")\n",
    "                    print(f\"📈 생성된 청크: {stats.get('numberOfNewDocumentsIndexed', 0)}개\")\n",
    "                \n",
    "                return True\n",
    "                \n",
    "            elif status == 'FAILED':\n",
    "                print(\"❌ Knowledge Base 동기화 실패\")\n",
    "                failure_reasons = job_status['ingestionJob'].get('failureReasons', [])\n",
    "                for reason in failure_reasons:\n",
    "                    print(f\"   - {reason}\")\n",
    "                return False\n",
    "                \n",
    "            elif status in ['IN_PROGRESS', 'STARTING']:\n",
    "                time.sleep(10)  # 10초 대기\n",
    "            else:\n",
    "                print(f\"⚠️ 예상치 못한 상태: {status}\")\n",
    "                time.sleep(5)\n",
    "                \n",
    "    except Exception as e:\n",
    "        print(f\"❌ 동기화 오류: {e}\")\n",
    "        return False\n",
    "\n",
    "# Knowledge Base 동기화 실행\n",
    "if kb_id and data_source_id:\n",
    "    sync_success = sync_knowledge_base(kb_id, data_source_id)\n",
    "    if sync_success:\n",
    "        print(\"\\n🎉 테스트 문서가 Knowledge Base에 성공적으로 추가되었습니다!\")\n",
    "    else:\n",
    "        print(\"\\n⚠️ 동기화에 문제가 있었습니다. 로그를 확인해주세요.\")\n",
    "else:\n",
    "    print(\"❌ Knowledge Base ID 또는 Data Source ID가 없습니다.\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 6. Knowledge Base 테스트 및 정리"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [\n",
    "        print(f\"📚 참조 소스 ({len(result['sources'])}개):\")\n",
    "        for i, source in enumerate(result['sources'][:3], 1):  # 상위 3개만 표시\n",
    "            filename = source.get('filename', 'Unknown')\n",
    "            content_preview = source.get('content', '')[:100] + '...' if len(source.get('content', '')) > 100 else source.get('content', '')\n",
    "            print(f\"  {i}. {filename}\")\n",
    "            print(f\"     {content_preview}\\n\")\n",
    "    else:\n",
    "        print(\"📚 참조 소스: 없음\")\n",
    "        \n",
    "    if result.get('error'):\n",
    "        print(f\"⚠️ 오류 발생: {result.get('error_code', 'Unknown')}\")\n",
    "        \n",
    "else:\n",
    "    print(\"⚠️ Knowledge Base ID가 설정되지 않아 테스트를 건너뜁니다.\")\n",
    "    print(\"01_aws_setup.ipynb를 먼저 실행하세요.\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 6. Knowledge Base 테스트 및 정리"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 22,
   "metadata": {},
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "INFO:__main__:🔍 Knowledge Base 검색 시작: RAG 시스템에 대해 설명해주세요....\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "👤 질문 1: RAG 시스템에 대해 설명해주세요.\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "INFO:__main__:✅ 검색 완료: 0개 소스 발견\n",
      "INFO:__main__:🔍 Knowledge Base 검색 시작: 그것의 장점은 무엇인가요?...\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "🤖 답변 1: Sorry, I am unable to assist you with this request....\n",
      "🔗 세션 ID 생성됨: 103da42e-b6eb-4506-928a-cb17708d835d\n",
      "\n",
      "👤 질문 2: 그것의 장점은 무엇인가요?\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "ERROR:__main__:❌ Bedrock API 오류 [ValidationException]: Invocation of model ID anthropic.claude-3-7-sonnet-20250219-v1:0 with on-demand throughput isn’t supported. Retry your request with the ID or ARN of an inference profile that contains this model. (Service: BedrockRuntime, Status Code: 400, Request ID: 3c1ce76e-beda-4644-b2f5-158d55447db7) (SDK Attempt Count: 1)\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "🤖 답변 2: 죄송합니다. 검색 중 오류가 발생했습니다: Invocation of model ID anthropic.claude-3-7-sonnet-20250219-v1:0 with on-demand throughput isn’t supported. Retry your request with the ID or ARN of an inference profile that c...\n",
      "\n",
      "✅ 대화 세션 테스트 완료\n"
     ]
    }
   ],
   "source": [
    "if kb_id:\n",
    "    # 첫 번째 질문 (세션 ID 없이 시작)\n",
    "    query1 = \"RAG 시스템에 대해 설명해주세요.\"\n",
    "    print(f\"👤 질문 1: {query1}\")\n",
    "    \n",
    "    # 세션 ID 없이 첫 번째 호출\n",
    "    result1 = bedrock_client.retrieve_and_generate(query1)\n",
    "    print(f\"🤖 답변 1: {result1['answer'][:200]}...\")\n",
    "    \n",
    "    # 응답에서 세션 ID 추출\n",
    "    session_id = result1.get('session_id')\n",
    "    if session_id:\n",
    "        print(f\"🔗 세션 ID 생성됨: {session_id}\\n\")\n",
    "        \n",
    "        # 두 번째 질문 (생성된 세션 ID 사용)\n",
    "        query2 = \"그것의 장점은 무엇인가요?\"\n",
    "        print(f\"👤 질문 2: {query2}\")\n",
    "        \n",
    "        result2 = bedrock_client.retrieve_and_generate(query2, session_id)\n",
    "        print(f\"🤖 답변 2: {result2['answer'][:200]}...\\n\")\n",
    "        \n",
    "        print(\"✅ 대화 세션 테스트 완료\")\n",
    "    else:\n",
    "        print(\"⚠️ 세션 ID가 생성되지 않았습니다.\")\n",
    "else:\n",
    "    print(\"⚠️ Knowledge Base ID가 설정되지 않아 세션 테스트를 건너뜁니다.\")\n",
    "\n",
    "# Knowledge Base 테스트 실행\n",
    "def test_knowledge_base():\n",
    "    \"\"\"업로드된 테스트 문서로 Knowledge Base 기능 테스트\"\"\"\n",
    "    \n",
    "    test_queries = [\n",
    "        \"RAG 시스템에 대해 설명해주세요.\",\n",
    "        \"RAG의 주요 장점은 무엇인가요?\",\n",
    "        \"AWS Bedrock의 Foundation Model에는 어떤 것들이 있나요?\",\n",
    "        \"멀티모달 문서 처리 과정을 설명해주세요.\"\n",
    "    ]\n",
    "    \n",
    "    print(\"\\n🧪 Knowledge Base 테스트 시작...\\n\")\n",
    "    \n",
    "    for i, query in enumerate(test_queries, 1):\n",
    "        print(f\"👤 질문 {i}: {query}\")\n",
    "        \n",
    "        try:\n",
    "            # RAG 검색 실행\n",
    "            result = bedrock_client.retrieve_and_generate(query)\n",
    "            \n",
    "            # 결과 출력\n",
    "            print(f\"🤖 답변 {i}: {result['answer'][:100]}...\")\n",
    "            \n",
    "            if result.get('sources'):\n",
    "                print(f\"📚 참조 소스: {len(result['sources'])}개 발견\")\n",
    "                for j, source in enumerate(result['sources'][:2], 1):  # 상위 2개만 표시\n",
    "                    filename = source.get('filename', 'Unknown')\n",
    "                    print(f\"   {j}. {filename}\")\n",
    "            else:\n",
    "                print(\"📚 참조 소스: 없음\")\n",
    "                \n",
    "            print(\"-\"*50)\n",
    "            \n",
    "        except Exception as e:\n",
    "            print(f\"❌ 테스트 {i} 실패: {e}\")\n",
    "            print(\"-\"*50)\n",
    "    \n",
    "    print(\"\\n✅ Knowledge Base 테스트 완료\")\n",
    "\n",
    "# 테스트 실행\n",
    "if kb_id and 'sync_success' in locals() and sync_success:\n",
    "    test_knowledge_base()\n",
    "else:\n",
    "    print(\"\\n⚠️ Knowledge Base가 준비되지 않아 테스트를 건너뜁니다.\")\n",
    "    print(\"5번 섹션을 먼저 실행하여 문서를 업로드하고 동기화하세요.\")\n",
    "\n",
    "# 테스트 문서 정리 (Knowledge Base를 빈 상태로 복원)\n",
    "def cleanup_test_documents():\n",
    "    \"\"\"테스트 문서들을 S3에서 삭제하고 Knowledge Base 재동기화\"\"\"\n",
    "    \n",
    "    print(\"\\n🧹 테스트 문서 정리 시작...\")\n",
    "    \n",
    "    # S3에서 테스트 문서들 삭제\n",
    "    deleted_files = []\n",
    "    \n",
    "    if 'test_files' in locals():\n",
    "        for filename in test_files:\n",
    "            try:\n",
    "                s3_client.delete_object(\n",
    "                    Bucket=s3_bucket_name,\n",
    "                    Key=f'documents/{filename}'\n",
    "                )\n",
    "                deleted_files.append(filename)\n",
    "                print(f\"🗑️ {filename} 삭제 완료\")\n",
    "                \n",
    "            except Exception as e:\n",
    "                print(f\"❌ {filename} 삭제 실패: {e}\")\n",
    "    else:\n",
    "        print(\"⚠️ 삭제할 테스트 파일 목록을 찾을 수 없습니다.\")\n",
    "        return\n",
    "    \n",
    "    print(f\"\\n📊 총 {len(deleted_files)}개 테스트 문서 삭제 완료\")\n",
    "    \n",
    "    # Knowledge Base 재동기화 (빈 상태로)\n",
    "    if deleted_files and kb_id and data_source_id:\n",
    "        print(\"\\n🔄 Knowledge Base 재동기화 시작 (빈 상태로 복원)...\")\n",
    "        \n",
    "        try:\n",
    "            # 새로운 Ingestion Job 시작\n",
    "            response = bedrock_agent_client.start_ingestion_job(\n",
    "                knowledgeBaseId=kb_id,\n",
    "                dataSourceId=data_source_id,\n",
    "                description='Cleanup - Remove test documents'\n",
    "            )\n",
    "            \n",
    "            job_id = response['ingestionJob']['ingestionJobId']\n",
    "            print(f\"📋 정리 Job ID: {job_id}\")\n",
    "            \n",
    "            # Job 완료 대기 (간단 버전)\n",
    "            print(\"⏳ 정리 작업 진행 중...\")\n",
    "            time.sleep(30)  # 30초 대기\n",
    "            \n",
    "            # 최종 상태 확인\n",
    "            final_status = bedrock_agent_client.get_ingestion_job(\n",
    "                knowledgeBaseId=kb_id,\n",
    "                dataSourceId=data_source_id,\n",
    "                ingestionJobId=job_id\n",
    "            )\n",
    "            \n",
    "            status = final_status['ingestionJob']['status']\n",
    "            print(f\"📊 최종 상태: {status}\")\n",
    "            \n",
    "            if status == 'COMPLETE':\n",
    "                print(\"✅ Knowledge Base 정리 완료! 이제 빈 상태입니다.\")\n",
    "            else:\n",
    "                print(f\"⚠️ 정리 작업이 아직 진행 중입니다. 상태: {status}\")\n",
    "                \n",
    "        except Exception as e:\n",
    "            print(f\"❌ 재동기화 오류: {e}\")\n",
    "    \n",
    "    print(\"\\n🎉 테스트 문서 정리 완료!\")\n",
    "    print(\"💡 Knowledge Base가 원래 빈 상태로 복원되었습니다.\")\n",
    "\n",
    "# 정리 실행 여부 확인\n",
    "print(\"\\n🤔 테스트 문서를 정리하시겠습니까?\")\n",
    "print(\"y: 정리 실행 (Knowledge Base를 빈 상태로 복원)\")\n",
    "print(\"n: 정리 건너뛰기 (테스트 문서 유지)\")\n",
    "\n",
    "cleanup_choice = input(\"선택 (y/N): \")\n",
    "\n",
    "if cleanup_choice.lower() in ['y', 'yes']:\n",
    "    cleanup_test_documents()\n",
    "else:\n",
    "    print(\"📝 테스트 문서가 Knowledge Base에 남아있습니다.\")\n",
    "    print(\"💡 나중에 수동으로 정리하거나 이 셀을 다시 실행하세요.\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 7. 유틸리티 함수들"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "def format_sources(sources: List[Dict[str, Any]]) -> str:\n",
    "    \"\"\"\n",
    "    소스 정보를 사용자 친화적 형태로 포맷팅\n",
    "    \n",
    "    Args:\n",
    "        sources: 소스 정보 리스트\n",
    "        \n",
    "    Returns:\n",
    "        포맷팅된 소스 문자열\n",
    "    \"\"\"\n",
    "    if not sources:\n",
    "        return \"참조 소스가 없습니다.\"\n",
    "    \n",
    "    formatted = []\n",
    "    for i, source in enumerate(sources, 1):\n",
    "        filename = source.get('filename', 'Unknown File')\n",
    "        content = source.get('content', '')[:150] + '...' if len(source.get('content', '')) > 150 else source.get('content', '')\n",
    "        \n",
    "        formatted.append(f\"{i}. **{filename}**\\n   {content}\")\n",
    "    \n",
    "    return \"\\n\\n\".join(formatted)\n",
    "\n",
    "def create_chat_response(query: str, bedrock_client: BedrockClient, session_id: str = None) -> Dict[str, Any]:\n",
    "    \"\"\"\n",
    "    채팅 인터페이스용 응답 생성\n",
    "    \n",
    "    Args:\n",
    "        query: 사용자 질문\n",
    "        bedrock_client: BedrockClient 인스턴스\n",
    "        session_id: 세션 ID\n",
    "        \n",
    "    Returns:\n",
    "        채팅용 응답 데이터\n",
    "    \"\"\"\n",
    "    result = bedrock_client.retrieve_and_generate(query, session_id)\n",
    "    \n",
    "    return {\n",
    "        'query': query,\n",
    "        'answer': result['answer'],\n",
    "        'sources_formatted': format_sources(result.get('sources', [])),\n",
    "        'sources_count': len(result.get('sources', [])),\n",
    "        'session_id': result.get('session_id'),\n",
    "        'timestamp': result.get('timestamp'),\n",
    "        'has_error': result.get('error', False)\n",
    "    }\n",
    "\n",
    "print(\"✅ 유틸리티 함수 정의 완료\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 8. 유틸리티 함수 테스트"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "if kb_id:\n",
    "    # 채팅 응답 테스트\n",
    "    test_query = \"멀티모달 RAG 시스템의 특징을 알려주세요.\"\n",
    "    \n",
    "    print(f\"🧪 유틸리티 함수 테스트\")\n",
    "    print(f\"질문: {test_query}\\n\")\n",
    "    \n",
    "    chat_response = create_chat_response(test_query, bedrock_client)\n",
    "    \n",
    "    print(\"📋 채팅 응답 구조:\")\n",
    "    print(f\"  - 답변 길이: {len(chat_response['answer'])} 문자\")\n",
    "    print(f\"  - 소스 개수: {chat_response['sources_count']}개\")\n",
    "    print(f\"  - 세션 ID: {chat_response['session_id']}\")\n",
    "    print(f\"  - 오류 여부: {chat_response['has_error']}\")\n",
    "    \n",
    "    print(\"\\n📚 포맷팅된 소스:\")\n",
    "    print(chat_response['sources_formatted'])\n",
    "    \n",
    "else:\n",
    "    print(\"⚠️ Knowledge Base ID가 설정되지 않아 유틸리티 테스트를 건너뜁니다.\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 9. 모듈 저장 (선택사항)\n",
    "\n",
    "개발이 완료되면 이 코드를 `src/bedrock_client.py`로 저장할 수 있습니다."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# 모듈로 저장하기 (선택사항)\n",
    "save_as_module = False  # True로 변경하면 저장됨\n",
    "\n",
    "if save_as_module:\n",
    "    module_code = '''\n",
    "import boto3\n",
    "import json\n",
    "import os\n",
    "from typing import Dict, List, Optional, Any\n",
    "from botocore.exceptions import ClientError\n",
    "import logging\n",
    "from datetime import datetime\n",
    "\n",
    "logger = logging.getLogger(__name__)\n",
    "\n",
    "class BedrockClient:\n",
    "    \"\"\"AWS Bedrock을 활용한 RAG 클라이언트\"\"\"\n",
    "    \n",
    "    def __init__(self, region_name: str = 'us-west-2', knowledge_base_id: str = None, model_id: str = None):\n",
    "        # ... (위의 클래스 코드와 동일)\n",
    "        pass\n",
    "    \n",
    "    # ... 나머지 메서드들\n",
    "'''\n",
    "    \n",
    "    with open('src/bedrock_client.py', 'w', encoding='utf-8') as f:\n",
    "        f.write(module_code)\n",
    "    \n",
    "    print(\"✅ src/bedrock_client.py 파일로 저장 완료\")\n",
    "else:\n",
    "    print(\"💡 save_as_module = True로 설정하면 모듈 파일로 저장됩니다.\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 🎯 다음 단계\n",
    "\n",
    "1. **문서 처리 모듈**: `03_document_processor.ipynb` 생성\n",
    "2. **Knowledge Base 연동**: `04_knowledge_base.ipynb` 생성\n",
    "3. **Streamlit UI**: `06_streamlit_basic.ipynb` 생성\n",
    "\n",
    "## 📝 참고사항\n",
    "\n",
    "- Knowledge Base에 문서가 없으면 의미있는 답변을 받기 어려울 수 있습니다.\n",
    "- 세션 ID를 사용하면 대화 컨텍스트가 유지됩니다.\n",
    "- 에러 처리가 포함되어 있어 안정적인 운영이 가능합니다."
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.9.23"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
